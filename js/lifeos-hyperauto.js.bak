// ============================================================
// FILE: js/lifeos-hyperauto.js
// M·ª•c ƒë√≠ch: LifeOS Phase 11 - Si√™u T·ª± ƒë·ªông h√≥a (10 t√≠nh nƒÉng)
// ============================================================

import { showNotification, generateID, toLocalISOString } from './common.js';
import { aiPowerHub } from './ai-power-hub.js';
import { saveUserData } from './firebase.js';

// ============================================================
// GLOBAL DATA
// ============================================================
let globalData = null;
let currentUser = null;

const STORAGE_KEY = 'lifeos_automation';

// ============================================================
// #81 - T·ª∞ ƒê·ªòNG H√ìA THEO √ù ƒê·ªäNH (Intent-Based Automation)
// Auto d·ª±a tr√™n √Ω ƒë·ªãnh, kh√¥ng c·∫ßn rules
// ============================================================
async function processIntent(intentText) {
    try {
        const result = await aiPowerHub.call(`
            Ph√¢n t√≠ch √Ω ƒë·ªãnh: "${intentText}"
            
            Tr·∫£ v·ªÅ JSON v·ªõi format:
            {
                "intent": "lo·∫°i √Ω ƒë·ªãnh (create_task/schedule/reminder/delegate/archive)",
                "action": "h√†nh ƒë·ªông c·ª• th·ªÉ",
                "params": { chi ti·∫øt ƒë·ªÉ th·ª±c hi·ªán },
                "confirm": true/false (n·∫øu c·∫ßn x√°c nh·∫≠n)
            }
        `, { maxTokens: 200 });

        // Parse and execute
        let parsed;
        try {
            const jsonMatch = result.content.match(/\{[\s\S]*\}/);
            parsed = JSON.parse(jsonMatch[0]);
        } catch {
            return { error: 'Kh√¥ng hi·ªÉu √Ω ƒë·ªãnh', raw: result.content };
        }

        return {
            understood: true,
            intent: parsed.intent,
            action: parsed.action,
            params: parsed.params,
            needsConfirmation: parsed.confirm
        };
    } catch (error) {
        return { error: 'Kh√¥ng th·ªÉ x·ª≠ l√Ω √Ω ƒë·ªãnh' };
    }
}

// ============================================================
// #82 - H√ÄNH ƒê·ªòNG THEO NG·ªÆ C·∫¢NH (Context-Aware Actions)
// Actions thay ƒë·ªïi theo context
// ============================================================
function getContextAwareActions() {
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay();
    const isWeekend = day === 0 || day === 6;

    const tasks = globalData?.tasks || [];
    const pendingTasks = tasks.filter(t => !t.completed);
    const overdueTasks = tasks.filter(t =>
        !t.completed && t.deadline && new Date(t.deadline) < now
    );

    const actions = [];

    // Morning context
    if (hour >= 7 && hour <= 9) {
        actions.push({
            id: 'morning_review',
            label: '‚òÄÔ∏è Xem c√¥ng vi·ªác h√¥m nay',
            priority: 'high'
        });
    }

    // Evening context
    if (hour >= 18 && hour <= 21) {
        actions.push({
            id: 'evening_wrap',
            label: 'üåô T·ªïng k·∫øt ng√†y',
            priority: 'medium'
        });
    }

    // Weekend context
    if (isWeekend) {
        actions.push({
            id: 'weekly_plan',
            label: 'üìÖ L·∫≠p k·∫ø ho·∫°ch tu·∫ßn m·ªõi',
            priority: 'medium'
        });
    }

    // Overdue context
    if (overdueTasks.length > 0) {
        actions.push({
            id: 'handle_overdue',
            label: `‚ö†Ô∏è X·ª≠ l√Ω ${overdueTasks.length} task qu√° h·∫°n`,
            priority: 'critical'
        });
    }

    // Light workload
    if (pendingTasks.length < 3) {
        actions.push({
            id: 'add_tasks',
            label: '‚ú® Th√™m c√¥ng vi·ªác m·ªõi',
            priority: 'low'
        });
    }

    // Heavy workload
    if (pendingTasks.length > 10) {
        actions.push({
            id: 'prioritize',
            label: 'üéØ S·∫Øp x·∫øp l·∫°i ∆∞u ti√™n',
            priority: 'high'
        });
    }

    return actions.sort((a, b) => {
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
}

// ============================================================
// #83 - T·∫†O TASK D·ª∞ ƒêO√ÅN (Predictive Task Creation)
// AI t·∫°o task tr∆∞·ªõc khi b·∫°n nghƒ©
// ============================================================
async function generatePredictedTasks() {
    const tasks = globalData?.tasks || [];
    const recentTasks = tasks.slice(-20);

    const patterns = recentTasks.map(t => ({
        title: t.title,
        category: t.category,
        dayOfWeek: new Date(t.createdAt).getDay()
    }));

    try {
        const result = await aiPowerHub.call(`
            D·ª±a tr√™n c√°c task g·∫ßn ƒë√¢y:
            ${JSON.stringify(patterns)}
            
            D·ª± ƒëo√°n 3 task ng∆∞·ªùi d√πng c√≥ th·ªÉ s·∫Ω c·∫ßn t·∫°o.
            Tr·∫£ v·ªÅ JSON array:
            [{"title": "t√™n task", "category": "category", "reason": "l√Ω do g·ª£i √Ω"}]
        `, { maxTokens: 300 });

        let predicted = [];
        try {
            const jsonMatch = result.content.match(/\[[\s\S]*\]/);
            predicted = JSON.parse(jsonMatch[0]);
        } catch {
            predicted = [];
        }

        return predicted;
    } catch (error) {
        return [];
    }
}

// ============================================================
// #84 - G·ª¢I √ù ·ª¶Y QUY·ªÄN TH√îNG MINH (Smart Delegation)
// AI suggest giao vi·ªác cho ai
// ============================================================
function suggestDelegation(taskId) {
    const tasks = globalData?.tasks || [];
    const task = tasks.find(t => t.id === taskId);

    if (!task || !task.title) return null;

    // Simple heuristics (would need contact data in real app)
    const suggestions = [];

    const titleLower = task.title.toLowerCase();

    if (titleLower.includes('design') || titleLower.includes('thi·∫øt k·∫ø')) {
        suggestions.push({ role: 'Designer', reason: 'Task li√™n quan ƒë·∫øn thi·∫øt k·∫ø' });
    }

    if (titleLower.includes('code') || titleLower.includes('dev')) {
        suggestions.push({ role: 'Developer', reason: 'Task li√™n quan ƒë·∫øn code' });
    }

    if (titleLower.includes('vi·∫øt') || titleLower.includes('content')) {
        suggestions.push({ role: 'Content Writer', reason: 'Task li√™n quan ƒë·∫øn n·ªôi dung' });
    }

    if (task.priority === 'low') {
        suggestions.push({ role: 'Intern/Junior', reason: 'Task ∆∞u ti√™n th·∫•p, ph√π h·ª£p ƒë·ªÉ ƒë√†o t·∫°o' });
    }

    return {
        task: task.title,
        suggestions,
        selfDoReason: suggestions.length === 0 ? 'Task n√†y n√™n t·ª± l√†m' : null
    };

    // ============================================================
    // #85 - T·ª∞ ƒê·ªòNG ∆ØU TI√äN AI (Auto-Prioritization)
    // Real-time priority reorder
    // ============================================================
    function autoPrioritizeTasks() {
        const tasks = globalData?.tasks || [];
        const now = new Date();

        const prioritized = tasks.filter(t => !t.completed).map(task => {
            let score = 50;

            // Deadline urgency
            if (task.deadline) {
                const deadline = new Date(task.deadline);
                const daysUntil = Math.ceil((deadline - now) / (1000 * 60 * 60 * 24));

                if (daysUntil <= 0) score += 50;
                else if (daysUntil <= 1) score += 40;
                else if (daysUntil <= 3) score += 25;
                else if (daysUntil <= 7) score += 10;
            }

            // Priority weight
            if (task.priority === 'high') score += 20;
            else if (task.priority === 'low') score -= 10;

            // Category weight
            if (task.category === 'C√¥ng vi·ªác') score += 5;

            return {
                ...task,
                autoScore: Math.min(100, score),
                suggestedPriority: score >= 70 ? 'high' : score >= 40 ? 'medium' : 'low'
            };
        });

        return prioritized.sort((a, b) => b.autoScore - a.autoScore);
    }

    // ============================================================
    // #86 - T·ª∞ L√äN L·ªäCH H·ªåP (Auto Schedule Meetings)
    // Auto t√¨m th·ªùi gian t·ªëi ∆∞u
    // ============================================================
    function findOptimalMeetingSlots(duration = 60, preferredHours = [9, 10, 14, 15]) {
        const calendarEvents = globalData?.calendarEvents || [];
        const now = new Date();
        const slots = [];

        // Check next 7 days
        for (let day = 0; day < 7; day++) {
            const checkDate = new Date(now);
            checkDate.setDate(checkDate.getDate() + day);

            if (checkDate.getDay() === 0 || checkDate.getDay() === 6) continue; // Skip weekends

            for (const hour of preferredHours) {
                const slotStart = new Date(checkDate);
                slotStart.setHours(hour, 0, 0, 0);

                const slotEnd = new Date(slotStart);
                slotEnd.setMinutes(slotEnd.getMinutes() + duration);

                // Check for conflicts
                const hasConflict = calendarEvents.some(event => {
                    const eventStart = new Date(event.start);
                    const eventEnd = new Date(event.end);
                    return (slotStart < eventEnd && slotEnd > eventStart);
                });

                if (!hasConflict && slotStart > now) {
                    slots.push({
                        start: slotStart.toISOString(),
                        end: slotEnd.toISOString(),
                        label: `${checkDate.toLocaleDateString('vi-VN', { weekday: 'short' })} ${hour}:00`
                    });
                }
            }
        }

        return slots.slice(0, 5);
    }

    // ============================================================
    // #87 - AI PH√ÇN LO·∫†I EMAIL (Email Triage)
    // T·ª± ph√¢n lo·∫°i v√† draft reply
    // ============================================================
    async function triageEmail(emailContent) {
        try {
            const result = await aiPowerHub.call(`
            Ph√¢n t√≠ch email:
            "${emailContent}"
            
            Tr·∫£ v·ªÅ JSON:
            {
                "category": "urgent/follow_up/fyi/spam",
                "priority": "high/medium/low",
                "summary": "t√≥m t·∫Øt 1 c√¢u",
                "suggestedReply": "g·ª£i √Ω tr·∫£ l·ªùi ng·∫Øn",
                "needsAction": true/false
            }
        `, { maxTokens: 300 });

            let parsed;
            try {
                const jsonMatch = result.content.match(/\{[\s\S]*\}/);
                parsed = JSON.parse(jsonMatch[0]);
            } catch {
                parsed = { error: 'Kh√¥ng th·ªÉ ph√¢n t√≠ch' };
            }

            return parsed;
        } catch (error) {
            return { error: 'Kh√¥ng th·ªÉ ph√¢n t√≠ch email' };
        }
    }

    // ============================================================
    // #88 - T·ª∞ T·ªî CH·ª®C T√ÄI LI·ªÜU (Auto File Organization)
    // Auto organize files v√† docs
    // ============================================================
    function suggestFileOrganization(fileName, fileType) {
        const rules = {
            'pdf': { folder: 'Documents', subfolder: 'PDFs' },
            'doc': { folder: 'Documents', subfolder: 'Word' },
            'docx': { folder: 'Documents', subfolder: 'Word' },
            'xls': { folder: 'Documents', subfolder: 'Excel' },
            'xlsx': { folder: 'Documents', subfolder: 'Excel' },
            'jpg': { folder: 'Media', subfolder: 'Images' },
            'png': { folder: 'Media', subfolder: 'Images' },
            'mp4': { folder: 'Media', subfolder: 'Videos' },
            'mp3': { folder: 'Media', subfolder: 'Audio' }
        };

        const ext = fileType || fileName.split('.').pop().toLowerCase();
        const rule = rules[ext] || { folder: 'Other', subfolder: 'Misc' };

        // Check for date patterns in filename
        const datePattern = /\d{4}[-_]\d{2}[-_]\d{2}/;
        if (datePattern.test(fileName)) {
            rule.subfolder = `${rule.subfolder}/ByDate`;
        }

        return {
            fileName,
            suggestedPath: `${rule.folder}/${rule.subfolder}`,
            reason: `File .${ext} n√™n ƒë∆∞·ª£c ƒë·∫∑t trong th∆∞ m·ª•c ${rule.folder}`
        };
    }

    // ============================================================
    // #89 - NH·∫ÆC NH·ªû TH√îNG MINH (Smart Reminders)
    // Nh·∫Øc ƒë√∫ng l√∫c, ƒë√∫ng c√°ch
    // ============================================================
    function getSmartReminders() {
        const tasks = globalData?.tasks || [];
        const now = new Date();
        const reminders = [];

        for (const task of tasks) {
            if (task.completed) continue;

            if (task.deadline) {
                const deadline = new Date(task.deadline);
                const hoursUntil = (deadline - now) / (1000 * 60 * 60);

                if (hoursUntil <= 24 && hoursUntil > 0) {
                    reminders.push({
                        taskId: task.id,
                        title: task.title,
                        type: 'deadline_soon',
                        message: `‚è∞ Deadline trong ${Math.round(hoursUntil)} gi·ªù!`,
                        urgency: 'high'
                    });
                } else if (hoursUntil <= 0) {
                    reminders.push({
                        taskId: task.id,
                        title: task.title,
                        type: 'overdue',
                        message: `üî¥ ƒê√£ qu√° h·∫°n ${Math.abs(Math.round(hoursUntil))} gi·ªù!`,
                        urgency: 'critical'
                    });
                }
            }

            // Check for forgotten tasks (created > 7 days, not touched)
            const created = new Date(task.createdAt);
            const daysSinceCreated = (now - created) / (1000 * 60 * 60 * 24);

            if (daysSinceCreated > 7 && !task.updatedAt) {
                reminders.push({
                    taskId: task.id,
                    title: task.title,
                    type: 'forgotten',
                    message: `üí§ T·∫°o t·ª´ ${Math.round(daysSinceCreated)} ng√†y tr∆∞·ªõc, ch∆∞a c√≥ ti·∫øn tri·ªÉn`,
                    urgency: 'low'
                });
            }
        }

        return reminders.sort((a, b) => {
            const urgencyOrder = { critical: 0, high: 1, medium: 2, low: 3 };
            return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];
        });
    }

    // ============================================================
    // #90 - WORKFLOW T·ª∞ T·ªêI ∆ØU (Self-Optimizing Workflows)
    // Quy tr√¨nh t·ª± improve
    // ============================================================
    function analyzeWorkflowEfficiency() {
        const tasks = globalData?.tasks || [];
        const completed = tasks.filter(t => t.completed);

        if (completed.length < 10) {
            return {
                status: 'insufficient_data',
                message: 'C·∫ßn √≠t nh·∫•t 10 task ho√†n th√†nh ƒë·ªÉ ph√¢n t√≠ch'
            };
        }

        // Analyze patterns
        const byCategory = {};
        const byDayOfWeek = {};

        for (const task of completed) {
            const cat = task.category || 'Kh√°c';
            byCategory[cat] = (byCategory[cat] || 0) + 1;

            const day = new Date(task.completedAt || task.createdAt).getDay();
            byDayOfWeek[day] = (byDayOfWeek[day] || 0) + 1;
        }

        // Find best day
        const bestDay = Object.entries(byDayOfWeek)
            .sort((a, b) => b[1] - a[1])[0];

        const dayNames = ['Ch·ªß nh·∫≠t', 'Th·ª© 2', 'Th·ª© 3', 'Th·ª© 4', 'Th·ª© 5', 'Th·ª© 6', 'Th·ª© 7'];

        // Calculate efficiency trends
        const recentTasks = completed.filter(t => {
            const date = new Date(t.completedAt || t.createdAt);
            return (new Date() - date) <= 14 * 24 * 60 * 60 * 1000;
        });

        const avgCompletionTime = recentTasks.reduce((sum, t) => {
            if (t.completedAt && t.createdAt) {
                return sum + (new Date(t.completedAt) - new Date(t.createdAt));
            }
            return sum;
        }, 0) / recentTasks.length / (1000 * 60 * 60 * 24); // in days

        return {
            status: 'analyzed',
            insights: {
                topCategory: Object.entries(byCategory).sort((a, b) => b[1] - a[1])[0]?.[0],
                bestDay: dayNames[parseInt(bestDay?.[0])] || 'N/A',
                avgCompletionDays: Math.round(avgCompletionTime * 10) / 10,
                totalCompleted: completed.length
            },
            recommendations: generateWorkflowRecommendations(avgCompletionTime, byDayOfWeek)
        };
    }

    function generateWorkflowRecommendations(avgTime, byDay) {
        const recs = [];

        if (avgTime > 5) {
            recs.push('Chia nh·ªè tasks ƒë·ªÉ ho√†n th√†nh nhanh h∆°n');
        }

        const weekendWork = (byDay[0] || 0) + (byDay[6] || 0);
        const weekdayWork = Object.entries(byDay)
            .filter(([d]) => d !== '0' && d !== '6')
            .reduce((sum, [, c]) => sum + c, 0);

        if (weekendWork > weekdayWork * 0.5) {
            recs.push('C√¢n nh·∫Øc gi·∫£m l√†m vi·ªác cu·ªëi tu·∫ßn');
        }

        if (recs.length === 0) {
            recs.push('Workflow hi·ªán t·∫°i ƒëang ho·∫°t ƒë·ªông t·ªët!');
        }

        return recs;
    }

    // ============================================================
    // UI RENDER
    // ============================================================
    function renderHyperAutoDashboard() {
        const container = document.getElementById('hyperauto-dashboard-content');
        if (!container) return;

        const contextActions = getContextAwareActions();
        const prioritized = autoPrioritizeTasks().slice(0, 5);
        const reminders = getSmartReminders().slice(0, 5);
        const meetingSlots = findOptimalMeetingSlots();
        const workflow = analyzeWorkflowEfficiency();

        container.innerHTML = `
        <div class="hyperauto-grid">
            <!-- Context Actions -->
            <div class="hyperauto-card context-card">
                <h3>üéØ G·ª£i √Ω Theo Ng·ªØ c·∫£nh</h3>
                <div class="action-list">
                    ${contextActions.map(a => `
                        <div class="action-item ${a.priority}">
                            <span>${a.label}</span>
                        </div>
                    `).join('') || '<p class="no-data">Kh√¥ng c√≥ g·ª£i √Ω</p>'}
                </div>
            </div>
            
            <!-- Auto Priority -->
            <div class="hyperauto-card priority-card">
                <h3>‚ö° T·ª± ƒë·ªông ∆Øu ti√™n</h3>
                <div class="priority-list">
                    ${prioritized.map((t, i) => `
                        <div class="priority-item">
                            <span class="priority-rank">#${i + 1}</span>
                            <span class="priority-title">${(t.title || 'Untitled').substring(0, 30)}...</span>
                            <span class="priority-score">${t.autoScore}</span>
                        </div>
                    `).join('') || '<p class="no-data">Kh√¥ng c√≥ task</p>'}
                </div>
            </div>
            
            <!-- Smart Reminders -->
            <div class="hyperauto-card reminders-card">
                <h3>üîî Nh·∫Øc nh·ªü Th√¥ng minh</h3>
                <div class="reminders-list">
                    ${reminders.map(r => `
                        <div class="reminder-item ${r.urgency}">
                            <span class="reminder-msg">${r.message}</span>
                            <span class="reminder-task">${(r.title || 'Untitled').substring(0, 25)}...</span>
                        </div>
                    `).join('') || '<p class="no-data">Kh√¥ng c√≥ nh·∫Øc nh·ªü</p>'}
                </div>
            </div>
            
            <!-- Meeting Slots -->
            <div class="hyperauto-card slots-card">
                <h3>üìÖ Slot H·ªçp Tr·ªëng</h3>
                <div class="slots-list">
                    ${meetingSlots.map(s => `
                        <div class="slot-item">
                            <span>${s.label}</span>
                        </div>
                    `).join('') || '<p class="no-data">Kh√¥ng t√¨m th·∫•y slot</p>'}
                </div>
            </div>
            
            <!-- Workflow Analysis -->
            <div class="hyperauto-card workflow-card">
                <h3>üìä Ph√¢n t√≠ch Workflow</h3>
                ${workflow.status === 'analyzed' ? `
                    <div class="workflow-insights">
                        <div class="insight-item">
                            <span class="insight-label">Ng√†y hi·ªáu qu·∫£ nh·∫•t</span>
                            <span class="insight-value">${workflow.insights.bestDay}</span>
                        </div>
                        <div class="insight-item">
                            <span class="insight-label">TB ng√†y ho√†n th√†nh</span>
                            <span class="insight-value">${workflow.insights.avgCompletionDays} ng√†y</span>
                        </div>
                        <div class="insight-item">
                            <span class="insight-label">Category ch√≠nh</span>
                            <span class="insight-value">${workflow.insights.topCategory}</span>
                        </div>
                    </div>
                    <div class="workflow-recs">
                        ${workflow.recommendations.map(r => `<p>üí° ${r}</p>`).join('')}
                    </div>
                ` : `<p class="no-data">${workflow.message}</p>`}
            </div>
            
            <!-- AI Intent -->
            <div class="hyperauto-card intent-card">
                <h3>ü§ñ AI Hi·ªÉu √ù ƒë·ªãnh</h3>
                <div class="intent-input">
                    <input type="text" id="intent-input" placeholder="N√≥i ƒëi·ªÅu b·∫°n mu·ªën l√†m...">
                    <button id="btn-process-intent">X·ª≠ l√Ω</button>
                </div>
                <div id="intent-result" class="intent-result"></div>
            </div>
        </div>
    `;

        setupHyperAutoEvents();
    }


    function setupHyperAutoEvents() {
        document.getElementById('btn-process-intent')?.addEventListener('click', async () => {
            const input = document.getElementById('intent-input');
            const result = document.getElementById('intent-result');
            const intent = input.value.trim();

            if (!intent) return;

            result.innerHTML = '‚è≥ ƒêang x·ª≠ l√Ω...';
            const processed = await processIntent(intent);

            if (processed.error) {
                result.innerHTML = `‚ùå ${processed.error}`;
            } else {
                result.innerHTML = `
                <strong>√ù ƒë·ªãnh:</strong> ${processed.intent}<br>
                <strong>H√†nh ƒë·ªông:</strong> ${processed.action}<br>
                ${processed.needsConfirmation ? '<button class="btn-confirm">‚úÖ X√°c nh·∫≠n</button>' : ''}
            `;
            }
        });
    }

    // ============================================================
    // INIT
    // ============================================================
    export function initHyperAuto(data, user) {
        globalData = data;
        currentUser = user;
        console.log('‚úÖ LifeOS Phase 11 - Hyper Automation ƒë√£ s·∫µn s√†ng');

        const menuBtn = document.querySelector('[data-target="hyperauto-dashboard"]');
        if (menuBtn) {
            menuBtn.addEventListener('click', () => {
                setTimeout(() => renderHyperAutoDashboard(), 100);
            });
        }
    }

    export {
        processIntent,
        getContextAwareActions,
        generatePredictedTasks,
        suggestDelegation,
        autoPrioritizeTasks,
        findOptimalMeetingSlots,
        triageEmail,
        suggestFileOrganization,
        getSmartReminders,
        analyzeWorkflowEfficiency,
        renderHyperAutoDashboard
    };
